#pragma config(Sensor, S2,     puckS,          sensorEV3_IRSensor)
#pragma config(Sensor, S3,     goalS,          sensorEV3_Color)
#pragma config(Sensor, S4,     wallS,          sensorEV3_Ultrasonic)
#pragma config(Motor,  motorA,          jawsM,         tmotorEV3_Medium, PIDControl, encoder)
#pragma config(Motor,  motorB,          rightM,        tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorC,          leftM,         tmotorEV3_Large, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorD,          liftM,         tmotorNXT, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//return the number of degrees to turn the wheel distance cm
float getDegrees(float distance){

	return (distance / (2 * PI * 3.3)) * 360;
}

//move the robot forward a given numver of cm
void moveForward( float distance, int speed){
	float target_degrees = getDegrees(distance);
	//displayCenteredTextLine(2, "Target degrees: %2.2f" , target_degrees);

	//ensure both motors going forwards
	setMotorReversed(leftM, false);
	setMotorReversed(rightM, false);
	
	setMotorSync(leftM, rightM, 1, 1);
  

	moveMotorTarget(leftM, target_degrees, speed);
	moveMotorTarget(rightM, target_degrees, speed);
}

//lift the jaws to the up position
void jawsHigh(void){
	setMotorReversed(liftM, true);
	moveMotorTarget(liftM, 110, 60);
	delay(500);
}

//lower the jaws to the down position
void jawsLow(void){
	//lower the motor till it hits the ground
	setMotorBrakeMode(liftM, 0);
	setMotorReversed(liftM, false);
	moveMotorTarget(liftM, 110, 60);
	delay(500);
	
	//raise the jaws up just a little bit so they don't scrape
	setMotorBrakeMode(liftM, 1);
	setMotorReversed(liftM, true);
	moveMotorTarget(liftM, 20, 60);
}

//open the jaws
void jawsOpen(void){
	setMotorReversed(jawsM, false);
	moveMotorTarget(jawsM, 115, 60);
}

//close the jaws
void jawsClose(void){
		setMotorReversed(jawsM, true);
		moveMotorTarget(jawsM, 115, 60);
}

//the number of degrees to turn the robot
//direction === true is left, false is right
void turn(bool direction, float degrees, int speed){
	float wheel_width = 16;
	float full_circumfrence= PI*wheel_width/2;

	float turn_distance = degrees/360 * full_circumfrence;
	float turn_degrees = getDegrees(turn_distance);

	if (!direction){
		setMotorReversed(leftM, false);
		setMotorReversed(rightM, true);

	}
	else {
		setMotorReversed(leftM, true);
		setMotorReversed(rightM, false);
	}

	moveMotorTarget(leftM, turn_degrees, speed);
	moveMotorTarget(rightM, turn_degrees, speed);

}

void exitMaze(void){
	displayCenteredTextLine(2, "IRval: %d", getIRDistance(puckS));
	while( getIRDistance(puckS) > 5){
				moveForward(2,30);
				delay(200);
				displayCenteredTextLine(2, "IRval: %d", getIRDistance(puckS));              
	}
	
	turn(true, 90, 20);
	delay(1000);
	displayCenteredTextLine(2, "IRval: %d", getIRDistance(puckS));
	
	while ( getIRDistance(puckS) > 30){
		moveForward(2, 30);
		delay(200);
		displayCenteredTextLine(2, "IRval: %d", getIRDistance(puckS));
	}
	
	turn(false, 80, 20);
	delay(500);
	displayCenteredTextLine(2, "IRval: %d", getIRDistance(puckS));
	
	moveForward(40,30);
	
	delay(200);
	displayCenteredTextLine(2, "IRval: %d", getIRDistance(puckS));
}


task main()
{
	waitForButtonPress();
	//jawsHigh();
	jawsLow();
	//jawsClose();
	exitMaze();
	
	while (1){
		waitForButtonPress();
		//moveForward(10);
		//turn(true, 90, 25);
		//jawsOpen();
		//sleep(1000);
		//jawsClose();

		//setMotorBrakeMode(liftM, 0);
		int enc = getMotorEncoder(liftM);
		displayCenteredTextLine(2, "enc: %d", enc);
		
		delay(100);
    
		
	}
}